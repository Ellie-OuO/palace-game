<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>後宮合成大戰 (Palace Suika)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS Reset 與基礎設定 */
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* 關鍵：禁止手機瀏覽器預設的下拉刷新與滑動手勢 */
            touch-action: none; 
            background: linear-gradient(135deg, #2b1111, #4a1c1c);
            font-family: "Microsoft JhengHei", sans-serif;
            color: #fce2b1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px; /* 針對手機縮小寬度限制 */
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
        }

        .sidebar { width: 60px; display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 10; }
        
        .evo-circle {
            border-radius: 50%;
            border: 2px solid #fce2b1;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background-repeat: no-repeat;
        }

        #canvas-container {
            position: relative;
            width: 320px; /* 手機友善寬度 */
            height: 480px; /* 手機友善高度 */
            background: linear-gradient(to bottom, #ffe8c3 0%, #f7d299 100%);
            border: 10px solid #5c3a21;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.2);
            overflow: hidden;
            touch-action: none; /* 確保畫布不觸發原生滾動 */
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        .score-box { text-align: center; background: rgba(92, 58, 33, 0.8); padding: 5px; border-radius: 8px; border: 1px solid #d4af37; width: 100%; }
        .score-box h3 { font-size: 12px; color: #fce2b1; }
        .score-box span { font-size: 16px; font-weight: bold; color: #fff; }

        /* 預測虛線 */
        #prediction-line {
            position: absolute; top: 0; width: 2px; height: 100%;
            background-image: linear-gradient(to bottom, transparent 50%, rgba(255,255,255,0.8) 50%);
            background-size: 100% 15px; pointer-events: none; display: none; z-index: 5;
        }

        /* 懸浮預覽圖：增加圓形裁切 */
        #hover-preview {
            position: absolute;
            top: 5px;
            transform: translateX(-50%);
            pointer-events: none;
            display: none;
            z-index: 6;
            filter: drop-shadow(0px 3px 3px rgba(0,0,0,0.3));
            border-radius: 50%;
            border: 2px solid #fce2b1;
            object-fit: cover;
        }

        #danger-line {
            position: absolute; top: 80px; left: 0; width: 100%; height: 2px;
            background-color: rgba(255, 0, 0, 0.5); border-top: 1px dashed red; pointer-events: none; z-index: 4;
        }

        #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
        }
        #restart-btn { margin-top: 15px; padding: 10px 20px; font-size: 18px; cursor: pointer; background: #d4af37; border: none; border-radius: 5px; }

        @media (max-width: 400px) {
            #game-wrapper { scale: 0.9; }
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="sidebar" id="evolution-path"></div>

    <div id="canvas-container">
        <img id="hover-preview" src="" alt="preview">
        <div id="prediction-line"></div>
        <div id="danger-line"></div>
        <div id="game-over-screen">
            <h2 style="color: #ff4d4d;">勝敗乃兵家常事</h2>
            <p>最終積分: <span id="final-score">0</span></p>
            <button id="restart-btn" onclick="location.reload()">重新開始</button>
        </div>
    </div>

    <div class="sidebar">
        <div class="score-box"><h3>積分</h3><span id="current-score">0</span></div>
        <div class="score-box"><h3>最高</h3><span id="high-score">0</span></div>
    </div>
</div>

<script>
    const BASE_IMG_SIZE = 200; 
    const LEVELS = [
        { radius: 15, img: 'images/level1.png' },
        { radius: 22, img: 'images/level2.png' },
        { radius: 30, img: 'images/level3.png' },
        { radius: 38, img: 'images/level4.png' },
        { radius: 48, img: 'images/level5.png' },
        { radius: 58, img: 'images/level6.png' },
        { radius: 68, img: 'images/level7.png' },
        { radius: 80, img: 'images/level8.png' },
        { radius: 95, img: 'images/level9.png' },
        { radius: 110, img: 'images/level10.png' }
    ];

    const { Engine, Render, Runner, Bodies, Composite, Events } = Matter;
    const engine = Engine.create();
    const container = document.getElementById('canvas-container');
    const width = 320; const height = 480;

    const render = Render.create({
        element: container,
        engine: engine,
        options: { width, height, wireframes: false, background: 'transparent' }
    });

    const ground = Bodies.rectangle(width/2, height + 20, width, 40, { isStatic: true, render: { fillStyle: '#5c3a21' } });
    const leftWall = Bodies.rectangle(-10, height/2, 20, height, { isStatic: true });
    const rightWall = Bodies.rectangle(width+10, height/2, 20, height, { isStatic: true });
    Composite.add(engine.world, [ground, leftWall, rightWall]);

    Render.run(render);
    Runner.run(Runner.create(), engine);

    let score = 0; let currentPreviewLevel = 0; let canDrop = true; let isGameOver = false;

    // 初始化左側路徑
    const evoPath = document.getElementById('evolution-path');
    LEVELS.forEach(lvl => {
        const div = document.createElement('div');
        div.className = 'evo-circle';
        div.style.width = '30px'; div.style.height = '30px';
        div.style.backgroundImage = `url(${lvl.img})`;
        evoPath.appendChild(div);
    });

    const hoverPreview = document.getElementById('hover-preview');
    const predictionLine = document.getElementById('prediction-line');

    function getNextLevel() { return Math.floor(Math.random() * 4); }
    currentPreviewLevel = getNextLevel();

    // --- 觸控與滑鼠事件處理 ---
    function handleMove(clientX) {
        if (isGameOver || !canDrop) return;
        const rect = container.getBoundingClientRect();
        let x = clientX - rect.left;
        const r = LEVELS[currentPreviewLevel].radius;
        x = Math.max(r, Math.min(x, width - r));

        predictionLine.style.left = `${x}px`;
        predictionLine.style.display = 'block';
        hoverPreview.src = LEVELS[currentPreviewLevel].img;
        hoverPreview.style.width = `${r * 2}px`;
        hoverPreview.style.height = `${r * 2}px`;
        hoverPreview.style.left = `${x}px`;
        hoverPreview.style.display = 'block';
    }

    function handleDrop(clientX) {
        if (isGameOver || !canDrop) return;
        canDrop = false;
        
        const rect = container.getBoundingClientRect();
        let x = clientX - rect.left;
        const r = LEVELS[currentPreviewLevel].radius;
        x = Math.max(r, Math.min(x, width - r));

        const scale = (r * 2) / BASE_IMG_SIZE;
        const ball = Bodies.circle(x, 40, r, {
            restitution: 0.2, friction: 0.1,
            render: { sprite: { texture: LEVELS[currentPreviewLevel].img, xScale: scale, yScale: scale } }
        });
        ball.level = currentPreviewLevel;
        ball.label = 'character';
        Composite.add(engine.world, ball);

        predictionLine.style.display = 'none';
        hoverPreview.style.display = 'none';

        setTimeout(() => {
            currentPreviewLevel = getNextLevel();
            canDrop = true;
        }, 600);
    }

    // 滑鼠事件
    container.addEventListener('mousemove', (e) => handleMove(e.clientX));
    container.addEventListener('mousedown', (e) => handleDrop(e.clientX));
    
    // 手機觸控事件 (必加 preventDefault)
    container.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleMove(e.touches[0].clientX);
    }, { passive: false });
    
    container.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleMove(e.touches[0].clientX);
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleDrop(e.changedTouches[0].clientX);
    }, { passive: false });

    // 合成邏輯
    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;
            if (bodyA.label === 'character' && bodyB.label === 'character' && bodyA.level === bodyB.level) {
                if (bodyA.isMerging || bodyB.isMerging) return;
                bodyA.isMerging = bodyB.isMerging = true;
                const nextLvl = bodyA.level + 1;
                if (nextLvl < LEVELS.length) {
                    const midX = (bodyA.position.x + bodyB.position.x) / 2;
                    const midY = (bodyA.position.y + bodyB.position.y) / 2;
                    Composite.remove(engine.world, [bodyA, bodyB]);
                    score += nextLvl * 10;
                    document.getElementById('current-score').innerText = score;
                    
                    const r = LEVELS[nextLvl].radius;
                    const scale = (r * 2) / BASE_IMG_SIZE;
                    const newBall = Bodies.circle(midX, midY, r, {
                        render: { sprite: { texture: LEVELS[nextLvl].img, xScale: scale, yScale: scale } }
                    });
                    newBall.level = nextLvl;
                    newBall.label = 'character';
                    Composite.add(engine.world, newBall);
                }
            }
        });
    });

    // 遊戲結束判定
Events.on(engine, 'beforeUpdate', () => {
    if (isGameOver) return;
    
    let isDanger = false;
    const bodies = Composite.allBodies(engine.world);
    const DANGER_LINE_Y = 100; // 紅線位置

    for (let i = 0; i < bodies.length; i++) {
        const body = bodies[i];
        if (body.label === 'character') {
            // 關鍵修正：只有當球體「已經不在頂部生成區」且「向上堆疊超過紅線」時才判定
            // 並且球體必須是相對靜止的（避免剛掉下去就被判輸）
            if (body.position.y < DANGER_LINE_Y && body.position.y > 60 && Math.abs(body.velocity.y) < 0.2) {
                isDanger = true;
                break;
            }
        }
    }

    if (isDanger) {
        gameOverTimer += 1000 / 60;
        if (gameOverTimer > 3000) triggerGameOver(); // 持續超過 3 秒才判輸
    } else {
        gameOverTimer = 0;
    }
});
</script>
</body>
</html>

