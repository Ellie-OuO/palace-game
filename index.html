<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>甄嬛合成大賽 - 高清修復版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        body {
            background: #2b1111;
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; overflow: hidden; touch-action: none;
        }
        #canvas-container {
            position: relative; width: 400px; height: 600px;
            background: #f7d299; border: 10px solid #5c3a21; border-radius: 10px;
        }
        #hover-preview {
            position: absolute; top: 10px; transform: translateX(-50%);
            pointer-events: none; border-radius: 50%; border: 2px solid #fff;
            display: none; z-index: 10; object-fit: cover;
        }
        #danger-line {
            position: absolute; top: 100px; width: 100%; height: 2px;
            background: rgba(255, 0, 0, 0.6); border-top: 1px dashed red;
        }
        #game-over {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.8); display: none; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 100;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <img id="hover-preview" src="">
    <div id="danger-line"></div>
    <div id="game-over">
        <h1>勝敗乃兵家常事</h1>
        <button onclick="location.reload()" style="padding:10px 20px; margin-top:20px; cursor:pointer;">重新開始</button>
    </div>
</div>

<script>
    const LEVELS = [
        { radius: 20, img: 'images/level1.png' },
        { radius: 30, img: 'images/level2.png' },
        { radius: 40, img: 'images/level3.png' },
        { radius: 50, img: 'images/level4.png' },
        { radius: 60, img: 'images/level5.png' },
        { radius: 75, img: 'images/level6.png' },
        { radius: 90, img: 'images/level7.png' },
        { radius: 105, img: 'images/level8.png' },
        { radius: 120, img: 'images/level9.png' },
        { radius: 140, img: 'images/level10.png' }
    ];

    const { Engine, Render, Runner, Bodies, Composite, Events } = Matter;
    const engine = Engine.create();
    const container = document.getElementById('canvas-container');
    const width = 400; const height = 600;

    // 預載圖片以防止渲染閃爍
    const imgObjects = LEVELS.map(level => {
        const img = new Image();
        img.src = level.img;
        return img;
    });

    const render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: width, height: height,
            wireframes: false,
            background: 'transparent',
            pixelRatio: window.devicePixelRatio // 關鍵：解決手機畫質模糊
        }
    });

    // 自定義渲染邏輯：解決圖片變形問題
    render.canvas.getContext('2d').imageSmoothingEnabled = true;
    render.canvas.getContext('2d').imageSmoothingQuality = 'high';

    const wallOptions = { isStatic: true, render: { visible: false } };
    Composite.add(engine.world, [
        Bodies.rectangle(width/2, height + 20, width, 40, wallOptions),
        Bodies.rectangle(-20, height/2, 40, height, wallOptions),
        Bodies.rectangle(width + 20, height/2, 40, height, wallOptions)
    ]);

    Render.run(render);
    Runner.run(Runner.create(), engine);

    let currentLevel = 0;
    let canDrop = true;
    let isGameOver = false;

    const hoverPreview = document.getElementById('hover-preview');

    function updatePos(clientX) {
        if (!canDrop || isGameOver) return;
        const rect = container.getBoundingClientRect();
        let x = clientX - rect.left;
        const r = LEVELS[currentLevel].radius;
        x = Math.max(r, Math.min(x, width - r));
        
        hoverPreview.src = LEVELS[currentLevel].img;
        hoverPreview.style.width = `${r * 2}px`;
        hoverPreview.style.height = `${r * 2}px`;
        hoverPreview.style.left = `${x}px`;
        hoverPreview.style.display = 'block';
    }

    container.addEventListener('mousemove', (e) => updatePos(e.clientX));
    container.addEventListener('touchmove', (e) => {
        e.preventDefault();
        updatePos(e.touches[0].clientX);
    }, { passive: false });

    function drop(clientX) {
        if (!canDrop || isGameOver) return;
        canDrop = false;
        hoverPreview.style.display = 'none';

        const rect = container.getBoundingClientRect();
        let x = clientX - rect.left;
        const r = LEVELS[currentLevel].radius;
        x = Math.max(r, Math.min(x, width - r));

        const ball = Bodies.circle(x, 50, r, {
            restitution: 0.2,
            friction: 0.1,
            render: {
                sprite: { texture: LEVELS[currentLevel].img, xScale: (r*2)/200, yScale: (r*2)/200 }
            }
        });
        ball.level = currentLevel;
        ball.label = 'char';
        Composite.add(engine.world, ball);

        setTimeout(() => {
            currentLevel = Math.floor(Math.random() * 4);
            canDrop = true;
        }, 800);
    }

    container.addEventListener('mousedown', (e) => drop(e.clientX));
    container.addEventListener('touchstart', (e) => {
        e.preventDefault();
        drop(e.touches[0].clientX);
    }, { passive: false });

    // 合成邏輯
    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;
            if (bodyA.label === 'char' && bodyB.label === 'char' && bodyA.level === bodyB.level) {
                if (bodyA.isMerging || bodyB.isMerging) return;
                const nextLvl = bodyA.level + 1;
                if (nextLvl < LEVELS.length) {
                    bodyA.isMerging = bodyB.isMerging = true;
                    const midX = (bodyA.position.x + bodyB.position.x) / 2;
                    const midY = (bodyA.position.y + bodyB.position.y) / 2;
                    Composite.remove(engine.world, [bodyA, bodyB]);
                    
                    const newBall = Bodies.circle(midX, midY, LEVELS[nextLvl].radius, {
                        render: { sprite: { texture: LEVELS[nextLvl].img, xScale: (LEVELS[nextLvl].radius*2)/200, yScale: (LEVELS[nextLvl].radius*2)/200 } }
                    });
                    newBall.level = nextLvl;
                    newBall.label = 'char';
                    Composite.add(engine.world, newBall);
                }
            }
        });
    });

    // 修正後的遊戲結束判定
    Events.on(engine, 'beforeUpdate', () => {
        const bodies = Composite.allBodies(engine.world);
        bodies.forEach(body => {
            if (body.label === 'char' && body.position.y < 100 && body.position.y > 60 && Math.abs(body.velocity.y) < 0.1) {
                isGameOver = true;
                document.getElementById('game-over').style.display = 'flex';
            }
        });
    });
</script>
</body>
</html>
